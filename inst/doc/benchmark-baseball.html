<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Benchmarks: baseball data</title>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}
</style>



</head>

<body>
<!--
%\VignetteEngine{knitr}
%\VignetteIndexEntry{Baseball benchmarks}
-->

<h1>Benchmarks: baseball data</h1>

<p>The purpose of these benchmarks is to be as fair as possible, to help understand the relatively performance tradeoffs of the different approaches. If you think my implementation of base or data.table equivalents is suboptimal, please let me know better ways.</p>

<p>Also note that I consider any significant performance difference between <code>dt</code> and <code>dt_raw</code> to be a bug in dplyr: for individual operations there should be very little overhead to calling data.table via dplyr. However, data.table may be significantly faster when performing the same sequence of operations as dplyr. This is because currently dplyr uses an eager evaluation approach so the individual calls to <code>[.data.table</code> don&#39;t get as much information about the desired result as the single call to <code>[.data.table</code> would if you did it by hand.</p>

<h2>Data setup</h2>

<p>The following benchmarks explore the performance on a somewhat realistic example: the <code>Batting</code> dataset from the Lahman package. It contains 96600 records on the batting careers of 96600 players from 1871 to 2012.</p>

<p>The first code block defines three alternative backends for the Batting dataset, and a players dataset that represents operations to be performed by player:</p>

<pre><code class="r">batting_df &lt;- tbl_df(Batting)
players_df &lt;- group_by(batting_df, playerID)

batting_dt &lt;- tbl_dt(Batting)
players_dt &lt;- group_by(batting_dt, playerID)
</code></pre>

<h2>Summarise</h2>

<p>Compute the average number of at bats for each player:</p>

<pre><code class="r">microbenchmark(
  dplyr_df = summarise(players_df, ab = mean(AB)),
  dplyr_dt = summarise(players_dt, ab = mean(AB)),
  dt_raw =   players_dt[, list(ab = mean(AB)), by = playerID],
  base =     tapply(batting_df$AB, batting_df$playerID, FUN = mean),
  times = 5, 
  unit = &quot;ms&quot;
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr   min     lq median     uq    max neval
#&gt;  dplyr_df   2.7   2.73   3.01   3.26   4.88     5
#&gt;  dplyr_dt  20.4  21.53  22.65  23.58  24.61     5
#&gt;    dt_raw  17.6  18.10  19.18  22.95  23.17     5
#&gt;      base 194.0 198.61 199.79 232.89 247.52     5
</code></pre>

<p>NB: base implementation captures computation but not output format, giving considerably less output.</p>

<p>However, this comparison is slightly unfair because both data.table and <code>summarise()</code> use tricks to find a more efficient implementation of <code>mean()</code>. Data table calls a <code>C</code> implementation of the <code>mean (using</code>.External(Cfastmean, B, FALSE)<code>and thus avoiding the overhead of S3 method dispatch).</code>dplyr::summarise uses a hybrid evaluation technique, where common functions are implemented purely in C++, avoiding R function call overhead.</p>

<pre><code class="r">mean_ &lt;- function(x) .Internal(mean(x))
microbenchmark(
  dplyr_df = summarise(players_df, ab = mean_(AB)),
  dplyr_dt = summarise(players_dt, ab = mean_(AB)),
  dt_raw =   players_dt[, list(ab = mean_(AB)), by = playerID],
  base =     tapply(batting_df$AB, batting_df$playerID, FUN = mean_),
  times = 5, 
  unit = &quot;ms&quot;
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr  min   lq median   uq  max neval
#&gt;  dplyr_df 13.8 13.9   14.4 15.9 16.7     5
#&gt;  dplyr_dt 18.6 19.7   22.0 22.9 24.9     5
#&gt;    dt_raw 18.2 18.5   20.6 21.8 23.2     5
#&gt;      base 85.4 85.8   87.1 90.2 90.9     5
</code></pre>

<h2>Arrange</h2>

<p>Arrange by year within each player:</p>

<pre><code class="r">microbenchmark(
  dplyr_df = arrange(players_df, yearID),
  dplyr_dt = arrange(players_dt, yearID),
  dt_raw =   batting_dt[order(playerID, yearID), ],
  base   =   batting_df[order(batting_df$playerID, batting_df$yearID), ],
  times = 2, 
  unit = &quot;ms&quot;
)  
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr   min    lq median    uq   max neval
#&gt;  dplyr_df  30.6  30.6   47.6  64.6  64.6     2
#&gt;  dplyr_dt 127.2 127.2  129.3 131.3 131.3     2
#&gt;    dt_raw  77.0  77.0   97.6 118.3 118.3     2
#&gt;      base  86.7  86.7  106.0 125.4 125.4     2
</code></pre>

<h2>Filter</h2>

<p>Find the year for which each player played the most games:</p>

<pre><code class="r">microbenchmark(
  dplyr_df = filter(players_df, G == max(G)),
  dplyr_dt = filter(players_dt, G == max(G)),
  base   =   batting_df[ave(batting_df$G, batting_df$playerID, FUN = max) ==
    batting_df$G, ],
  times = 2, 
  unit = &quot;ms&quot;  
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr   min    lq median    uq   max neval
#&gt;  dplyr_df  32.7  32.7   34.8  36.9  36.9     2
#&gt;  dplyr_dt  44.2  44.2   44.4  44.5  44.5     2
#&gt;      base 116.0 116.0  117.2 118.4 118.4     2
</code></pre>

<p>I&#39;m not aware of a single line data table equivalent (<a href="http://stackoverflow.com/questions/16573995/">see SO 16573995</a>). Suggetions welcome.  dplyr currently doesn&#39;t support hybrid evaluation for logical comparison, but it is scheduled for 0.2 (see <a href="https://github.com/hadley/dplyr/issues/113">#113</a>), this should give an additional (10-20x) speed up.</p>

<h2>Mutate</h2>

<p>Rank years based on number of at bats:</p>

<pre><code class="r">microbenchmark(
  dplyr_df  = mutate(players_df, rank = rank(desc(AB))),
  dplyr_dt  = mutate(players_dt, rank = rank(desc(AB))),
  dt_raw =    players_dt[, list(rank = rank(desc(AB))), by = playerID],
  times = 2, 
  unit = &quot;ms&quot;
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr min  lq median  uq max neval
#&gt;  dplyr_df 629 629    636 642 642     2
#&gt;  dplyr_dt 635 635    652 669 669     2
#&gt;    dt_raw 624 624    645 665 665     2
</code></pre>

<p>Compute year of career:</p>

<pre><code class="r">microbenchmark(
  dplyr_df = mutate(players_df, cyear = yearID - min(yearID) + 1),
  dplyr_dt = mutate(players_dt, cyear = yearID - min(yearID) + 1),
  dt_raw =   players_dt[, list(cyear = yearID - min(yearID) + 1), by = playerID],
  times = 5, 
  unit = &quot;ms&quot;
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr  min   lq median   uq  max neval
#&gt;  dplyr_df 36.9 37.9   38.2 44.3 78.0     5
#&gt;  dplyr_dt 42.8 42.9   46.0 47.8 82.9     5
#&gt;    dt_raw 28.5 28.9   29.0 29.2 29.5     5
</code></pre>

<p>Rank is a relatively expensive operation and <code>min()</code> is relatively cheap, showing the the relative performance overhead of the difference techniques.</p>

<p>dplyr currently has some support for hybrid evaluation of window functions:</p>

<pre><code class="r">microbenchmark(
  dplyr_df  = mutate(players_df, rank = min_rank(AB)),
  dplyr_dt  = mutate(players_dt, rank = min_rank(AB)),
  dt_raw =    players_dt[, list(rank = min_rank(AB)), by = playerID],
  times = 2, 
  unit = &quot;ms&quot;
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr   min    lq median    uq   max neval
#&gt;  dplyr_df  38.7  38.7   39.1  39.5  39.5     2
#&gt;  dplyr_dt 670.1 670.1  698.9 727.8 727.8     2
#&gt;    dt_raw 671.3 671.3  676.7 682.1 682.1     2
</code></pre>

<h2>Joins</h2>

<p>We conclude with some quick comparisons of joins. First we create two new datasets: <code>master</code> which contains demographic information on each player, and <code>hall_of_fame</code> which contains all players inducted into the hall of fame.</p>

<pre><code class="r">master_df &lt;- tbl_df(Master) %.% select(playerID, hofID, birthYear)
hall_of_fame_df &lt;- tbl_df(HallOfFame) %.% filter(inducted == &quot;Y&quot;) %.% 
  select(hofID, votedBy, category)

master_dt &lt;- tbl_dt(Master) %.% select(playerID, hofID, birthYear)
hall_of_fame_dt &lt;- tbl_dt(HallOfFame) %.% filter(inducted == &quot;Y&quot;) %.% 
  select(hofID, votedBy, category)
</code></pre>

<pre><code class="r">microbenchmark(
  dplyr_df = left_join(master_df, hall_of_fame_df, by = &quot;hofID&quot;),
  dplyr_dt = left_join(master_dt, hall_of_fame_dt, by = &quot;hofID&quot;),
  base     = merge(master_df, hall_of_fame_df, by = &quot;hofID&quot;, all.x = TRUE),
  times = 10, 
  unit = &quot;ms&quot;
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr   min    lq median    uq   max neval
#&gt;  dplyr_df  1.12  1.20   1.27  1.50  1.59    10
#&gt;  dplyr_dt  3.34  3.49   3.77  4.25 13.73    10
#&gt;      base 33.27 34.50  36.17 40.27 41.21    10
</code></pre>

<pre><code class="r">
microbenchmark(
  dplyr_df = inner_join(master_df, hall_of_fame_df, by = &quot;hofID&quot;),
  dplyr_dt = inner_join(master_dt, hall_of_fame_dt, by = &quot;hofID&quot;),
  base     = merge(master_df, hall_of_fame_df, by = &quot;hofID&quot;),
  times = 10, 
  unit = &quot;ms&quot;
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr   min    lq median   uq  max neval
#&gt;  dplyr_df 0.909 0.984   1.02 1.08 1.19    10
#&gt;  dplyr_dt 2.327 2.428   2.66 3.13 3.56    10
#&gt;      base 2.447 2.920   2.99 3.42 4.50    10
</code></pre>

<pre><code class="r">
microbenchmark(
  dplyr_df = semi_join(master_df, hall_of_fame_df, by = &quot;hofID&quot;),
  dplyr_dt = semi_join(master_dt, hall_of_fame_dt, by = &quot;hofID&quot;),
  times = 10, 
  unit = &quot;ms&quot;
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr  min    lq median    uq  max neval
#&gt;  dplyr_df 0.90 0.901  0.934 0.951 1.06    10
#&gt;  dplyr_dt 1.35 1.385  1.400 1.406 1.88    10
</code></pre>

<pre><code class="r">
microbenchmark(
  dplyr_df = anti_join(master_df, hall_of_fame_df, by = &quot;hofID&quot;),
  dplyr_dt = anti_join(master_dt, hall_of_fame_dt, by = &quot;hofID&quot;),
  times = 10, 
  unit = &quot;ms&quot;
)
</code></pre>

<pre><code>#&gt; Unit: milliseconds
#&gt;      expr  min   lq median   uq  max neval
#&gt;  dplyr_df 1.24 1.28   1.35 1.44 1.49    10
#&gt;  dplyr_dt 2.41 2.72   2.81 2.88 3.11    10
</code></pre>

</body>

</html>
